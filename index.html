<!DOCTYPE html>
<html lang="en">
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <style>
    canvas {
        padding: 0;
        margin: auto;
        display: block;
        width: 800px;
        height: 600px;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
    }
  </style>
</head>

<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
  var bombY;
  var bombX;
  var bombSpeed = 4;
  var bombTarget = 'f';
  var projectileLive = false;
  var projectileY;
  var projectileX;
  var projectileSpeed = 8;
  var level = 1;
  var targetKeyIndex;
  var letterDestroyed = false;
  var bombsAway = false;
  var livesLeft = 3;
  var hitsThisLevel = 0;
  var sequenceIndex = 0;
  var indexOfNextChar = 0;
  var bridgeLevel = false;
  const CHARS_IN_BRIDGE_LEVEL = 20;

  // This is in order of which level they appear
  var keys = ['f','j','d','k','s','l','a',';','g','h',
      'e','i','r','u','w','o','x',',',
      '3','8','c','m','z','.','v','n','b','\/'];

  // This can be used to generate the keyMap
  var keyboard = [['1','2','3','4','5','6','7','8','9','0','-','='],
        ['q','w','e','r','t','y','u','i','o','p','\[','\]','\\'],
        ['a','s','d','f','g','h','j','k','l',';','\''],
        ['z','x','c','v','b','n','m',',','.','\/']];

  // Stores the text for bridge level
  var bridgeText;

  // Where they sit on the keyboard is generated
  var keyMap = {};

  function info(message) {
    console.log("INFO: " + message);
  }

  function debug(message) {
    console.log("DEBUG: " + message);
  }

  function generateKeyMap() {
    debug("generating key map with keyboard " + keyboard);
    for(var i = 0; i < keyboard.length; i++) {
      var keyboardRow = keyboard[i];
      debug("got the keyboardRow " + keyboardRow);
      for(var j = 0; j < keyboardRow.length; j++) {
        var key = keyboardRow[j];
        debug("Adding key " + key + " at " + i + "," + j);
        keyMap[key] = {'col': j, 'row': i};
      }
    }
  }

  String.prototype.replaceAt=function(index, character) {
    return this.substr(0, index) + character + this.substr(index+character.length);
  }

  function updateKeyPress(evt) {
    var keypressedChar = charFor(evt.which);
    if (isBridgeLevel()) {
      var nextChar = bridgeText.charAt(indexOfNextChar);
      debug("Trying to remove char at " + indexOfNextChar + " which is " + nextChar);
      if (keypressedChar == nextChar) {
        if (indexOfNextChar >= CHARS_IN_BRIDGE_LEVEL - 1) {
          finishedBridgeLevel();
        }
        bridgeText = bridgeText.replaceAt(indexOfNextChar, " ");
        indexOfNextChar++;
      } else {
        info("Borp!");
      }
    } else {
      if (projectileLive == false) {
        if (keys.indexOf(keypressedChar) < noKeysInPlay()) {
          projectileY = yForKey(keypressedChar);
          projectileX = xForKey(keypressedChar);
          projectileLive = true;
        }
      }
    }
  }

  function finishedBridgeLevel() {
    info("Succeed!");
    bridgeLevel = false;
    bridgeText = false;
    indexOfNextChar = 0;
  }

  function charFor(which) {
    var keysNotMappingProperly = {
      186 : ';',
      188 : ',',
      190 : '.'
    };
    var keypressedChar = keysNotMappingProperly[which] || String.fromCharCode(which).toLowerCase();
    debug("Key code " + which + " is " + keypressedChar);
    return keypressedChar;
  }

  window.onload = function() {
    generateKeyMap();
    canvas = document.getElementById('gameCanvas');
    canvasContext = canvas.getContext('2d');

    var framesPerSecond = 30;
    setInterval(updateAll, 1000/framesPerSecond);

    window.addEventListener('keydown', updateKeyPress, false);
  }

  function updateAll() {
    if (livesLeft <= 0) {
      gameOver();
    } else {
      if (isBridgeLevel()) {
        moveAllBridge();
        drawAllBridge();
      } else {
        moveAll();
        drawAll();
      }
    }
  }

  function isBridgeLevel() {
    return bridgeLevel;
  }

  function getBridgeText() {
    if (bridgeText) return bridgeText;

    var total_text = "aaa ;;; sss lll ddd kkk fff jjj " +
      "aa ss dd ff aa ss dd ff " +
      ";; ll kk jj ;; ll kk jj " +
      "ad ad as as ask ask ad ad as as ask ask " +
      ";;; lll kkk jjj ;;; lll kkk jjj " +
      ";;; lll kkk jjj ;;; lll kkk jjj " +
      "add add fad fad jak jak sad sad fall fall jak jak " +
      "add fad; add fad; add jak; add jak; sad fall; sad fall; " +
      "a a as as fad fad dad dad ;; ;; ja ja ka ka la la " +
      "jas jas kas kas las las jas jas kas kas las las jas jas " +
      "jf kd ls ;a jf kd ls ;a jf kd ls ;a jf kd ls ;a " +
      "fall fall sad sad all all all sad falls; all sad falls; " +
      "lad lad asks asks sas sas kass kass " +
      "lad asks sas kass; lad asks sas kass; " +
      "a a sad sad dad dad fall fall; a sad dad fall; " +
      "dad dad sad sad kad kad lad lad " +
      "dad dad; sad sad; kad kad; lad lad; " +
      "lad; dad; sad; lass; lad; dad; sad; lass; " +
      "fad fad; ads ads; all all; fad ads all lads; " +
      "ask a lad; a fall ad; ask a dad; " +
      "as a lad; as a dad; as a sad lass;  ";

    var randy = Math.floor(Math.random() * (total_text.length - CHARS_IN_BRIDGE_LEVEL));
    debug("Returning text starting at " + randy);
    return total_text.substring(randy, randy + CHARS_IN_BRIDGE_LEVEL);
  }

  function drawAllBridge() {
    drawCanvas();

    bridgeText = getBridgeText();
    var bridgeLines = bridgeText.match(/.{1,60}/g);
    var lineY = 200;
    for (var i = 0; i < bridgeLines.length; i++) {
      colorText(bridgeLines[i], 30, lineY, 'white');
      lineY += 25;
    }
  }

  function moveAllBridge() {
  }

  function moveAll() {
    moveBomb();

    moveProjectile();

    projectileBombHandling();

    projectileLetterHandling();
  }

  function gameOver() {
    colorText('GAME OVER', 280, 300, 'white',40);
    colorText('Refresh page to start again.', 235, 340, 'white');
    info("Game over");
  }

  function projectileBombHandling() {
    // projectile gets less going up, bomb gets more going down
    if ((projectileY < bombY) && (projectileX == bombX)) {
      debug("Bullseye!");
      hitsThisLevel++;
      if(hitsThisLevel >= 3) {
        level++;
        if (level % 4)
          startBridgeLevel();
        hitsThisLevel = 0;
      }
      projectileLive = false;
      bombsAway = false;
    }
  }

  function startBridgeLevel() {
    bridgeLevel = true;
  }

  function moveProjectile() {
    if (projectileLive) {
      projectileY -= projectileSpeed;
      if (projectileY < 0) {
        projectileLive = false;
      }
    }
  }

  function moveBomb() {
    bombY += bombSpeed;
    if (projectileY <= bombY) {
      debug("You bombed me!");
    }
  }

  function projectileLetterHandling() {
    if (bombsAway) {
      var targetKey = keys[targetKeyIndex];
      var targetKeyY = yForKey(targetKey);
      debug("For key " + targetKey + ", Is " + bombY + " >= " + targetKeyY);
      if (bombY >= targetKeyY) {
        debug("Letter destroyed!");
        livesLeft -= 1;
        bombsAway = false;
        letterDestroyed = targetKey;
        dropBomb();
      }
    }
  }

  function dropBomb() {
    if (!bombsAway) {
      bombY = 0;
      var randy = Math.random() * noKeysInPlay();
      targetKeyIndex = Math.floor(randy);
      bombsAway = true;
      var targetKey = keys[targetKeyIndex];
      bombX = xForKey(targetKey);
    } else {
      debug("Aiming at " + targetKeyIndex);
      colorText('#', bombX, bombY, 'white'); // draw bomb
    }
  }

  function drawCanvas() {
    colorRect(0, 0, canvas.width, canvas.height, 'black'); // clear screen
  }

  function drawAll() {
    drawCanvas();

    // colorText("Lives: " + livesLeft, 20, 30, 'white'); // draw bomb
    if (livesLeft >= 1)
      colorText('\u2764', 20, 30, 'white'); // draw bomb
    if (livesLeft >= 2)
      colorText('\u2764', 40, 30, 'white'); // draw bomb
    if (livesLeft >= 3)
      colorText('\u2764', 60, 30, 'white'); // draw bomb

    dropBomb();

    // draw projectile
    debug("Projectile x is " + projectileX + "," + projectileY);
    if (projectileLive) {
      colorText('|', projectileX, projectileY, 'white');
    }

    drawKeys();

    if (letterDestroyed) {
      drawExplosions();
    }
  }

  function drawExplosions() {
    sequenceIndex++;
    var charToDraw = Math.floor(sequenceIndex / 3);
    // var explosionSequence = ['$','%','@','!','*'];
    var explosionSequence = ['#','/','-','\\','|','/','-','\\','|'];
    if (sequenceIndex >= (explosionSequence.length - 1) * 3) {
      letterDestroyed = false;
      sequenceIndex = 0;
    }

    var destroyedX = xForKey(letterDestroyed);
    var destroyedY = yForKey(letterDestroyed);
    colorText(explosionSequence[charToDraw], destroyedX, destroyedY, 'white');
  }

  function noKeysInPlay() {
    return level * 2;
  }

  function drawKeys() {
    for (var i = 0; i < noKeysInPlay(); i++) {
      var key = keys[i];
      var keyX = xForKey(key);
      var keyY = yForKey(key);

      debug("For index " + i + " drawing key " + key + " at " + keyX + "," + keyY);
      if (letterDestroyed == key) {
        continue;
      }
      colorText(keys[i], keyX, keyY, 'white'); // draw keys
    }
  }

  function yForKey(key) {
    const ROW_MARGIN = 400;
    const ROW_GAP = 40;

    return keyMap[key].row * ROW_GAP + ROW_MARGIN;
  }

  function xForKey(key) {
    const COL_MARGIN = 1;
    const COL_GAP = 80;
    const OFFSET = 20;

    return keyMap[key].col * COL_GAP + COL_MARGIN + (OFFSET * keyMap[key].row);
  }

  function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
    canvasContext.fillStyle = fillColor;
    canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
  }

  function colorCircle(centerX, centerY, radius, fillColor) {
    canvasContext.fillStyle = fillColor;
    canvasContext.beginPath();
    canvasContext.arc(centerX, centerY, radius, 0, Math.PI*2, true);
    canvasContext.fill();
  }

  function colorText(showWords, textX, textY, fillColor, size) {
    if (!size) {
      canvasContext.font="20px Courier New";
    } else {
      canvasContext.font=size + "px Arial";
    }

    canvasContext.fillStyle = fillColor;
    canvasContext.fillText(showWords, textX, textY);
  }
</script>
</body>
</html>
